%Edited 7-25-21


%% set up parameters
clear
clc
close all

% path = '/Users/nitaprabhu/Documents/Traction Force Script/Test 2'; % input folder
path = 'X:\Max\2021_07_07_F127GellCharacterization\First Half\Test 4'; % input folder
% path = 'X:\Max\RegistrationSampleData';

tif_paths = dir([path, '\*.tif']);

%output folder
output_folder_name = 'output';
output_folder = mkdir(strcat(path, '\', output_folder_name));
%Save to output folder

%% New Loop -- 7/25/21


for ii = 1:length(tif_paths)
    
    %filename = [tif_paths(ii).folder, '/',tif_paths(ii).name];
%     imgfile = '20%f127d1dayold15002.tif';
    filename = [tif_paths(ii).folder, '\',tif_paths(ii).name];
    imgfile = filename;
    stack_info = imfinfo(imgfile);
    
    
    z_start = 1;            % layer with bottom of the channel
    z_end = length(stack_info);              % layer with top of the channel
    z_range = 522:3:534; % user-defined range where channel looks ideal, ~15 images
    % uses only DIC images
    
    thresh_sensitivity = 0.6;     % threshold for creating binary image
    
    min_area = 5E3;               %minimum area to be feed into object detection
    max_area = 1E9;                %maximum area to be feed into object detection
    min_solid = 0.4;              %minimum solidity for object detection
    max_solid = 1;               %maximum solidity for object detection
    
    x_size = stack_info(1).Width;
    y_size = stack_info(1).Height;
    
    %% Edge Detection Test
    use_these = [];
    for b = 60:3:z_end
        channel = [];
        fill_val = [];
        channel2 = [];
        boundaries = [];
        boundaries2 = [];
        
        img_temp = imread(imgfile, b); % read in DIC images
        img_temp_bin = imbinarize(img_temp,'adaptive','ForegroundPolarity',...
            'bright','Sensitivity',0.6);
        [~, threshold] = edge(img_temp_bin, 'sobel');
        fudgeFactor = 0.65;
        BWs = edge(img_temp_bin, 'sobel', threshold*fudgeFactor);
        
        se90 = strel('line', 3, 90);
        se0 = strel('line', 3, 0);
        BWsdil = imdilate(BWs, [se90 se0]);
        BWdfill = imfill(BWsdil, 'holes');
        
        BWnobord = imclearborder(BWdfill, 4);
        
        seD = strel('diamond', 1);
        BWfinal = imerode(BWnobord, seD);
        BWfinal = imerode(BWfinal, seD);
        
        
        BWoutline = bwperim(BWfinal);
        Segout = img_temp_bin;
        Segout(BWoutline) = 255;
        img = imfill(BWoutline, 'holes'); % creates outline of the channel
        check(b) = sum(sum(img));
        if check(b) >= 20000
            use_these = [use_these, b];
        end
    end  
    k = 1;
 
    for i = 1:length(use_these)
        channel = [];
        fill_val = [];
        channel2 = [];
        boundaries = [];
        boundaries2 = [];
        
        img_temp = imread(imgfile, use_these(i)); % read in DIC images
        img_temp_bin = imbinarize(img_temp,'adaptive','ForegroundPolarity',...
            'bright','Sensitivity',0.6);
        [~, threshold] = edge(img_temp_bin, 'sobel');
        fudgeFactor = 0.65;
        BWs = edge(img_temp_bin, 'sobel', threshold*fudgeFactor);
        
        se90 = strel('line', 3, 90);
        se0 = strel('line', 3, 0);
        BWsdil = imdilate(BWs, [se90 se0]);
        BWdfill = imfill(BWsdil, 'holes');
        
        BWnobord = imclearborder(BWdfill, 4);
        
        seD = strel('diamond', 1);
        BWfinal = imerode(BWnobord, seD);
        BWfinal = imerode(BWfinal, seD);
        
        
        BWoutline = bwperim(BWfinal);
        Segout = img_temp_bin;
        Segout(BWoutline) = 255;
        img = imfill(BWoutline, 'holes'); % creates outline of the channel
        
        img_lines = img;
       
        [channel(:,2), channel(:,1)] = find(img); 
        
        % finding edges of the channel
        
        
        %%
        left_most = [];
        right_most = [];
        col_num = [];
        m = 2;
        for jj = 2:size(channel,1) 
        % finds the boundaries of the channel per column
            if channel(jj, 1) ~= channel(jj-1,1)
                left_most(m) = channel(jj,2);
                right_most(m-1) = channel(jj-1,2);
                col_num(m) = channel(jj,1);
                m = m+1;
            end
        end
        %%
        left_most(end) = [];
        col_num(end) = [];
        boundaries = [col_num', left_most', right_most'];
        
        % fills in the space of the channel within the boundaries
        for kk = 2:size(boundaries,1)
            for mm = 1:boundaries(kk,3)
                if mm >= boundaries(kk,2)
                    img_lines(mm, boundaries(kk,1)) = 1;
                end
            end
        end
        
        [fill_val(:,2), fill_val(:,1)] = find(img_lines);
        P = polyfit(fill_val(:,1), fill_val(:,2), 1); 
        % linear regression coefficients of channel
        angle_val(k) = atand(P(1)); % angle between channel and x-axis
        
        
        img_test = imrotate(img_temp_bin, 90+angle_val(k)); 
        % rotates channel to align with vertical
 %%
        % ---------------------------------------------
        % Translation of Channel
        BW2 = bwpropfilt(img_test,'Area',[min_area max_area],6);
        BW2 = imfill(BW2, 'holes');
        BW2 = bwareafilt(BW2, 2);
        BW2_comp = BW2; % isolates the two edges of the channel
        
        [channel2(:,1), channel2(:,2)] = find(BW2); % finding edges of the channel (Y,X)
        sorted_channel2 = sortrows(channel2); % sorts by row
        
        left_most2 = [];
        right_most2 = [];
        row_num2 = [];
        mm = 2;
        
%         for aa = 2:size(sorted_channel2,1)
%             
%             if sorted_channel2(aa, 1) ~= sorted_channel2(aa-1,1)
%                 left_most2(mm) = sorted_channel2(aa,2);
%                 right_most2(mm-1) = sorted_channel2(aa-1,2);
%                 row_num2(mm) = sorted_channel2(aa,1);
%                 mm = mm+1;
%             end
%             
%         end
        for aa = 2:size(sorted_channel2,1)
            if sorted_channel2(aa,2) - sorted_channel2(aa-1,2) > 50 ...
                    && sorted_channel2(aa,1) == sorted_channel2(aa-1,1)
                left_most2(mm) = sorted_channel2(aa-1,2);
                right_most2(mm) = sorted_channel2(aa,2);
                row_num2(mm) = sorted_channel2(aa,1);
                mm = mm+1;
                break
            end
        end
                                                          
        %right_most2(mm - 1) = sorted_channel2(end,2);
        boundaries2 = [row_num2', left_most2', right_most2'];
        % boundaries of the channel by row
        
        for bb = 2:size(boundaries2,1)
            for cc = 1:boundaries2(bb,3)
                if cc >= boundaries2(bb,2)
                    BW2(boundaries2(bb,1),cc) = 1;
                else
                    BW2(boundaries2(bb,1),cc) = 0;
                end
            end
        end % fills in channel
        
        stats = regionprops(BW2,'Centroid'); % finds center of the channel
        
        img_size = size(BW2);
        img_center = img_size/2;
        x_shift(k) = img_center(1) - stats.Centroid(2);
        y_shift(k) = img_center(2) - stats.Centroid(1);
        k = k+1;
    end


average_angle = mean(angle_val);
average_x_shift = mean(x_shift);
average_y_shift = mean(y_shift);

%% Actual Translation
    
    img_binarized = {};
    img_initial = {};
    img_rot = {};
    img_trans = {};
    l = 1;
    for iii = 3:3:z_end
        
        img_initial{l} = imread(imgfile,iii);
        img_rot{l} = imrotate(img_initial{l}, 90+average_angle);
        img_trans{l} = imtranslate(img_rot{l}, [average_x_shift, average_y_shift]);
        sizes(l) = size(img_trans{l},1);
        l = l+1;
    end
    
    %% Saving Image Trials
    
    tiff_name = strcat(path, '\', output_folder_name, '\', tif_paths(ii).name);
    t = Tiff(tiff_name,'w');
    tagStruct.ImageLength = max(sizes);
    tagStruct.ImageWidth = max(sizes);
    tagStruct.Photometric = Tiff.Photometric.MinIsBlack;
    tagStruct.BitsPerSample = 16;
    tagStruct.SamplesPerPixel = 1;
    tagStruct.PlanarConfiguration = Tiff.PlanarConfiguration.Chunky;
    tagStruct.Software = 'MATLAB';
    
    setTag(t,tagStruct)
    write(t,squeeze(im2uint16(img_trans{1})));
    
    for p = 2:length(img_trans)
        writeDirectory(t);
        setTag(t,tagStruct)
        write(t,squeeze(im2uint16(img_trans{p})));
    end
    
    close(t)
end
%%
% img_test = imrotate(img_temp_bin, 90 + angle_val);
% img_shifted = imtranslate(img_test, [x_shift y_shift]);
% imshowpair(img_shifted, img_test, 'montage')
% hold on
% plot([img_center(1) img_center(1)], [0 img_size(1)], [0 img_size(1)], [img_center(1) img_center(1)],...
%     'LineWidth', 2)
% hold off
%%

% img_edge_test = imread(imgfile,36);
% img_edge = imbinarize(img_edge_test,'adaptive','ForegroundPolarity','bright','Sensitivity',0.6);

% %% Edge Detection Test
%
% [~, threshold] = edge(img_edge, 'sobel');
% fudgeFactor = 0.7;
% BWs = edge(img_edge, 'sobel', threshold*fudgeFactor);
% imshow(BWs)
% se90 = strel('line', 3, 90);
% se0 = strel('line', 3, 0);
% BWsdil = imdilate(BWs, [se90 se0]);
% BWdfill = imfill(BWsdil, 'holes');
%
% BWnobord = imclearborder(BWdfill, 4);
%
% seD = strel('diamond', 1);
% BWfinal = imerode(BWnobord, seD);
% BWfinal = imerode(BWfinal, seD);
%
%
% BWoutline = bwperim(BWfinal);
% Segout = img_edge_test;
% Segout(BWoutline) = 255;
% imshowpair(labeloverlay(img_edge_test, BWfinal), Segout, 'montage')
%
% % try BWareafill or something along those lines then filter for the largest
% % object identified, should take out extraneous bubbles
%
% %% read images and create object stats
% close all
% k = 1;
% for i = z_start:3:143*3
%     img_temp = imread(imgfile,i);
%     img_temp_bin = imbinarize(img_temp,'adaptive','ForegroundPolarity','bright','Sensitivity',0.6);
%     BW2 = bwpropfilt(img_temp_bin,'Area',[min_area max_area],6);
%     BW2 = bwpropfilt(BW2,'Solidity',[min_solid max_solid]);
%     stats = regionprops(BW2,'area','Centroid','Orientation','Solidity');
%     ori(k) = arrayfun(@(x) x.Orientation, stats); % angle between x-axis and ellipse created with channel
%     cent_cord{k} = arrayfun(@(x) x.Centroid, stats, 'UniformOutput', false);
%     k = k + 1;
% end
% % image is read as y, x, z
%
%
% %% create stats on orientation;
% [ori,TF] = rmoutliers(ori);
% cent_cord = cent_cord(~TF); % centroid coordinates of all non-outlier images
%
% for i = 1:length(ori)
%     axang = mean(ori)*pi/180*[0 0 1]; % average orientation angle for rotation about Z
%     rot_mat = rotationVectorToMatrix(axang);
%     adj_x_val = cent_cord{i}(1)-x_size/2; % shifts the centroid in relation to center of image
%     adj_y_val = cent_cord{i}(2)-y_size/2; % shifts y-coord of centroid
%     rot_vals = rot_mat(1:2, 1:2) * [adj_x_val; adj_y_val]; % rotates adjusted coords in relation to Z
% end
%
% % disp_vec_y = [0 mean(cent_y_dist)] / rot_mat(1:2,1:2) + [x_size/2 y_size/2];
% % disp_vec_x = [0 mean(cent_x_dist)] / rot_mat(1:2, 1:2) + [x_size/2 y_size/2];
% % disp_vec = [disp_vec_x(1) disp_vec_y(2)];
% % calculated average center of all channels in stack
%
% % cent_cord_rot = cellfun(@(x) [x(1)-x_size/2 x(2)-y_size/2]*rot_mat_xy,cent_cord,'UniformOutput',false);
% % cent_y_dist = cellfun(@(x) x(2), cent_cord_rot);
%
%
%
% %img_temp_rot = imrotate(img_temp,-mean(ori));
%
% % for i = 143
% img_temp_rot = imrotate(img_temp_bin, ori(end));
% adj_diff = cent_cord{end} - disp_vec;
% img_rot_adj = imtranslate(img_temp_rot, adj_diff./[x_size y_size]);
% % end
%
% subplot(1,2,1)
% imshow(img_temp_bin)
% subplot(1,2,2)
% imshow(img_temp_rot)
%
% % %% calculate rotation matrix
% % pr = [0.1625,0.1625,0.3];
% % % orig_vec = [0,100,0].*pr;
% % % rot_vec = [yz_vec(2),x_disp,yz_vec(1)].*pr;
% % orig_vec = [x_disp,0,0].*pr;
% % rot_vec = [100,yz_vec(2),yz_vec(1)].*pr;
% % rot_mat = vrrotvec2mat(vrrotvec(rot_vec,orig_vec));
% %
% % %% calculate translational motion   (currently assume only need to move along y direction)
% % % channel_width = 25;    % in um
% % % channel_height = 10;    % in um
% % % standard_img = zeros(z_length,y_size);
% % % standard_img(floor(z_length - channel_height/pr(3)):z_length,floor(y_size/2 - channel_width/(2*pr(1))):ceil(y_size/2 + channel_width/(2*pr(1)))) = 1;
% % middle_img = reshape(img_stack(:,round(y_size/2),:),y_size,[])';
% % BW2 = bwpropfilt(~imbinarize(middle_img),'convex',[2000 3000]);
% % stats = regionprops(BW2,'centroid');
% % cent_cord = stats(1).Centroid;
% % y_disp = y_size/2 - cent_cord(1);
% %
% % %% perform transform
% % beadpos = x{1,1}{1,1};
% % beadpos_tranformed = beadpos - [disp_vec 0];
% % beadpos_tranformed = beadpos_tranformed*rot_mat;
%
%
