%% Inverse Problem Script - Main File
%{
Author:         Keshav Patel
PI:             Wesley Legant
Date Created:   7/11/2019
Description:    This file takes displacement data generated by COMSOL and
computes the solution to the inverse problem (i.e. find solution vector f
to the linear system G*f=u, where u is a displacement vector and G is the
Green's matrix for the given geometry. This script calls functions which
parses txt/csv data from COMSOL to generate the Green's matrix and
displacement vector (in this folder) and calls functions within the
*regularization tools* package by PC Hansen (found in "private" to
compute the regulatization parameter and inverse solution. L-curve,
displacement vector, and solution vector are displayed and saved in the
"plots" folder.

Date Modified:  1/11/2021
Modificationns: Fixed naming and parseMeshData function.
Max Hockenberry
%}
clc; close all; clear;
today = datestr(now, 'mm-dd');
%Load regInputs.mat if available; otherwise initialize variables
if isfile('regInputs.mat')
   load('regInputs.mat') 
else
    inputs = struct();
end
%% Start and Run regGUI

regGUI = regGUI(inputs);

while(regGUI.closenum ~= 1)
    pause(1)
end


%After program attempts to close, grab variable information and store in
%workplace

inputs.greensLoad = regGUI.loadGreen;
inputs.nodalSoln = regGUI.loadNodal;
inputs.greensSave = regGUI.saveGreen;
inputs.comsol = regGUI.loadComsol;
inputs.loadPT = regGUI.loadPT;
inputs.dispSource = regGUI.dispSource;
inputs.outputName = regGUI.outputName;
inputs.loadFile = regGUI.loadFile;

%% Define conditions used to create inverse problem
%Choose COMSOL data files to create G and u
greensMatLoadFile = inputs.greensLoad;%'Z:\Regan\2019_10_10(TFM)\data_FLAT_20kPa_Analysis\GreensMat_block_10_22_19.mat';
greensMatDataFile = inputs.nodalSoln;%'Z:\Regan\2019_10_10(TFM)\data_FLAT_20kPa_Analysis\nodalSolutions_10_22_19.csv';
greensMatSaveAsFile = inputs.greensSave;%'Z:\Regan\2019_10_10(TFM)\data_FLAT_20kPa_Analysis\GreensMat_block_10_22_19.mat';
COMSOLGeometryMeshFile = inputs.comsol;%'Z:\Regan\2019_10_10(TFM)\data_FLAT_20kPa_Analysis\meshData_10_22_19.mphtxt'; %by default, COMSOL saves this to '../data/meshData.mphtxt'
particleTrackingDataFile = inputs.loadPT;%Z:\Regan\2019_10_10(TFM)\data_FLAT_20kPa_Analysis\cell3\cell3_tracking.mat';

outputFoldPlots = fullfile(inputs.outputName,'plots');
mkdir(fullfile(inputs.outputName,'plots'))

%Choose whether Greens Matrix should be loaded from another file or
%    generated from a COMSOL csv file
%enter -1 if you already have the data loaded and will not clear vars
%    beforehand
%parse load file inputs from yes/no
if strcmp(inputs.loadFile,'Yes')
    loadFromFile = 1;
end
if strcmp(inputs.loadFile,'No')
    loadFromFile = 0;
end

%Regularization method
method = 'tikh';

%Choose where displacement vector is taken from
%  -1 = u is already defined
%   0 = load in .mat file;
%   1 = linear combination of Green's matrix columns (see next constant)
%parseVecSource
if strcmp(inputs.dispSource, 'Predefined')
   dispVectorSource = -1;
end
if strcmp(inputs.dispSource, 'Load from .mat file')
    dispVectorSource = 0;
end
if strcmp(inputs.dispSource, 'Linear Combination')
    dispVectorSource = 1;
end
%if dispVectorSource == 1, give the linear combination of Green's matrix
%   vectors that you want to test
greensColumns = [1];%round(linspace(1,1944,5));
weights = [1];%(-1).^round(linspace(1,1944,5)).*round(linspace(1,1944,5))./1944;

%Standard deviation is defined in this script relative to the maximum power
%   in the Green's matrix (p). Use noiseStdFac to define the noise standard
%   deviation as 10^(p-noiseStdFac). Define as NaN for no noise
noiseStdFac = NaN;

%The name that figures at the end of the script are saved as
runName = [today inputs.outputName];
%save the inputs

regGUI.delete
save('regInputs.mat','inputs')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Setup

% Load Green's matrix

if loadFromFile == 1
    disp('Loading an already computed Greens Matrix')
    load(greensMatLoadFile)
%     load('nonSingular_block_flipped_RPM_10_16_19.mat');
    disp('done')
elseif loadFromFile == 0
    disp('Reading COMSOL mesh data')
    % Find centroids of where forces are applied (for plotting purposes)
    [meshPointsCoords, meshPointsIndex, meshSurfaceIndex, desiredBoundaryInd] = parseMeshData(COMSOLGeometryMeshFile);
    
    %the mesh centroids will be used to visually approximate where forces were
    %   applied
    meshCentroid = [];
    for i = 1:size(meshSurfaceIndex)
        %look for a meshElement that lives on the surface you applied forces to
        if find(desiredBoundaryInd == meshSurfaceIndex(i))% & sum(i==[1,6,12,17,23,28,34,39,45,50,56,61,67,72,78,83,89,94,100,105,111,116,122,127,133,138,144,149,155,160])
             currMesh = meshPointsIndex(i,:)+1;
            currCoord1 = meshPointsCoords(currMesh(1),:);
            currCoord2 = meshPointsCoords(currMesh(2),:);
            currCoord3 = meshPointsCoords(currMesh(3),:);
            meshCentroid = [meshCentroid; (currCoord1+currCoord2+currCoord3)/3];
        end
    end
    disp('Reading COMSOL displacement data')
    [G, displacedPtsMat] = GreensMatParamSweep(greensMatDataFile);
    
    disp(['Greens Matrix compiled. It is a ' num2str(size(G,1)) ' x ' num2str(size(G,2)) ' matrix.'])
    disp('Computing SVD')
    [U,s,V] = csvd(G);
    disp(['condition number = ' num2str(abs(max(s)/min(s)))]);
    nonSingular = s>(max(size(G))*eps(norm(G)));
    
    disp('saving Greens Matrix')
    %fix the name for saving the greensMatSaveFile
    greensMatSaveAsFile = fullfile(greensMatSaveAsFile, strcat('GreensMatrix',today,'.mat'))
    save(greensMatSaveAsFile, 'G', 'U', 's', 'V', 'meshCentroid', 'displacedPtsMat','-v7.3')

end

%% Set up displacement vector u
if dispVectorSource ~= -1
    % Load displacement vector
    if dispVectorSource == 0
        disp('loading vector from particle tracking file')
        load(particleTrackingDataFile);
        uAllTimes = cell(length(matches),1);
    % Displacement measurements may or may not be centered in our image
    % coordinates. Before computing tractions, we need to translate these
    % measurements to align with the coordinates of force application in
    % our comsole model.
    
    %Flip the bead coordinates and displacements to match Comsol geometry
    
    for ii = 1:length(matches)
%         matches{ii,1}(:,1:3)=rotatePointCloudX(matches{ii,1}(:,1:3),-.85);
%         matches{ii,1}(:,4:6)=rotatePointCloudX(matches{ii,1}(:,4:6),-.85);
%         matches{ii,1}(:,3)=-matches{ii,1}(:,3);
%         matches{ii,1}(:,6)=-matches{ii,1}(:,6);
%         displacements{ii,1}(:,3)=-displacements{ii,1}(:,3);
    end
    
    trans=[mean(matches{1,1}(:,4)),mean(matches{1,1}(:,5)),-(100-prctile(abs(matches{1,1}(:,6)),99))];
    
    for ii = 1:length(matches)
matches{ii}(:,1)=matches{ii}(:,1)-trans(1);
matches{ii}(:,2)=matches{ii}(:,2)-trans(2);
matches{ii}(:,3)=matches{ii}(:,3)-trans(3);
    end
        
        for i = 1:length(matches)
            u = zeros(size(G,1),1);
            
            
            %The displacements are interpolated component-wise (i.e. first
            %the x directions, then y, then z). 
            %x direction
            F = scatteredInterpolant(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3), displacements{i}(:,1));
            u(1:3:end) = F([displacedPtsMat(1:3:end,1), displacedPtsMat(1:3:end,2), displacedPtsMat(1:3:end,3)]);
            %y direction
            F = scatteredInterpolant(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3), displacements{i}(:,2));
            u(2:3:end) = F([displacedPtsMat(2:3:end,1), displacedPtsMat(2:3:end,2), displacedPtsMat(2:3:end,3)]);
            %z direction
            F = scatteredInterpolant(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3), displacements{i}(:,3));
            u(3:3:end) = F([displacedPtsMat(3:3:end,1), displacedPtsMat(3:3:end,2), displacedPtsMat(3:3:end,3)]);
            
            %after interpolation, check to see which, if any, points on the
            %grid needed to be calculated through extrapolation
            F = scatteredInterpolant(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3), displacements{i}(:,3),'linear','none');
            extrapolationTest = F([displacedPtsMat(3:3:end,1), displacedPtsMat(3:3:end,2), displacedPtsMat(3:3:end,3)]);
            isExtrapolated = isnan(extrapolationTest);
            if sum(isExtrapolated) > 0
                warning(['There were ' num2str(sum(isExtrapolated)) ' points ' ...
                    'that needed to be extrapolated. See the variable ' ...
                    '"ptsExtrapolated" for a list. Consider reducing the ' ...
                    'range over which you selected cut points in COMSOL.'])
                dispPtsCondensed = displacedPtsMat(1:3:end,1:3);
                ptsExtrapolated = dispPtsCondensed(isExtrapolated,:);
                
                %Uncomment this block (or copy/paste into Command Window)
                %to see a plot of where extrapolated points are
                %{
                figure
                scatter3(displacedPtsMat(1:3:end,1),displacedPtsMat(1:3:end,2),displacedPtsMat(1:3:end,3),'.')
                hold on
                scatter3(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3),'.')
                scatter3(ptsExtrapolated(:,1),ptsExtrapolated(:,2),ptsExtrapolated(:,3),'k')
                K = convhull(matches{i}(:,1),matches{i}(:,2),matches{i}(:,3));
                trimesh(K,matches{i}(:,1),matches{i}(:,2),matches{i}(:,3))
                legend('Gridded Points', 'Particle Tracking Bead Locations',...
                    'Extrapolated Points','location','eastoutside')
                %}
                
                %filter=(displacedPtsMat(:,1)>-650)&(displacedPtsMat(:,1)<650)&(displacedPtsMat(:,2)>-650)&(displacedPtsMat(:,2)<700);
                %u(~filter)=0;
                
            end
            
            uAllTimes{i} = u;
        end
    elseif dispVectorSource == 1
        disp('generating displacements vector from linear combo of Greens Matrix columns')
        u = sum(repmat(weights,size(G,1),1).*G(:,greensColumns),2);
        uAllTimes = {u};
        %this is for checking solutions, trying to troubleshoot option, use
        %this to have displacement field that is a linear combination of
        %forces, 1 with all 0's for instance. If you don't then something
        %is wrong with the matrix inversion. Is this robust to noise,
        %predefined simulated fields. 
    end
end



%% Start Regularization for Each Time Point

    figure
    [reg_corner,rho,eta,reg_param] = l_curve(U,s,uAllTimes{1},'tikh');
%     saveas(gcf, ['../plots/' runName 'Lcurve_temp.png'])

for i = 1:length(uAllTimes)
    u = uAllTimes{i};
    
    %% Warning/Error Throwing
    if size(G,1) < size(G,2)
        warning('system given by G is underdefined') %underdetermined
    end
%     if sum(nonSingular) ~= size(G,2)
%         warning('Greens matrix is not full rank')
%     end
    
    if size(meshCentroid,1) ~= size(G,2)/3
        error('The given mesh does not match the given Greens matrix data')
    elseif size(u,1) ~= size(G,1)
        error('displacement vector dimension does not agree with Greens matrix')
    end
    
    %% Calculate Regularization Parameter
    %these functions and its subroutines are from "regtools" package by PC Hansen
    disp('Calculating Regularization Parameter')
    
    %Pseudo-inverse solution (i.e. solution without regularization - for
    %  comparison purposes)
    fMinPseudo = tikhonov(U,s,V,u,0,'tikh');
    
    %calculate l-curve and find regularization parameter
%     figure
    [reg_corner,rho,eta,reg_param] = l_curve(U,s,u,'tikh',fMinPseudo);
    saveas(gcf, [outputFoldPlots '\' runName 'Lcurve_temp.png'])
    
    %% Find force profile that minimizes error
    disp('Error Optimization')
    
    %calculate solution based on regularization parameter found above
    fMinTikh = tikhonov(U,s,V,u,reg_corner,'tikh');
    tractions{i}=fMinTikh;
    absErrorTikh = norm(fMinTikh-fMinPseudo);
    disp(['|Tikh - psuedoInv| = ' num2str(absErrorTikh)]);
    
%     %calculate solution based on an arbitrary regularization parameter (for
%     %  comparison purposes)
    regArb = 1e-4;
    fMinTikhArb = tikhonov(U,s,V,u,regArb,'tikh');
    absErrorTikhArb = norm(fMinTikhArb-fMinPseudo);
    disp(['|Tikh - psuedoInv| = ' num2str(absErrorTikhArb)]);
    
    %write solution to a file readable by Amira
    text = buildAmiraMesh(fMinTikh, meshCentroid+[trans(1),trans(2),trans(3)]);
    fid = fopen(['./plots/' 'AmiraTetraVectors' today num2str(i) '.am'],'wt');
    fprintf(fid, text);
    fclose(fid);
    
end
%% Plotting GUI
% Want to generate output image GUI with differing layers, measured
% displacements, recovered bead displacements, bead dispalcement errors,
% cellular tractions, then some plots of other statistics
imageAnalysisGUI = imageAnalysisGUI2(uAllTimes,tractions,meshCentroid,dispPtsCondensed,trans);

while(imageAnalysisGUI.closenum ~= 1)
    pause(1)
end

imageAnalysisGUI.delete
%% Plot
%%{
disp('plotting')
figure
d = 1;
quiver3(displacedPtsMat(1:3:end,1),displacedPtsMat(1:3:end,2),displacedPtsMat(1:3:end,3),u(1:3:end),u(2:3:end),u(3:3:end),0)
xlabel('x')
ylabel('y')
zlabel('z')
title({'Displacements Used to Solve Inverse Problem'})
%view([90 0]) %use this if you want a view of the yz plane
% axis([domain_x domain_y domain_z])
saveas(gcf, ['./plots/' runName 'displacements_temp.png'])

% figure
% subplot(1,3,1)
% quiver3(meshCentroid(:,1),meshCentroid(:,2),meshCentroid(:,3),d*fMinPseudo(1:3:end),d*fMinPseudo(2:3:end),d*fMinPseudo(3:3:end),0)
% xlabel('x')
% ylabel('y')
% zlabel('z')
% title('Force Profile Computed via PseudoInverse')
% %view([90 0]) %use this if you want a view of the yz plane
% % axis([domain_x domain_y [0 10]])

subplot(1,3,2)
scale=0.5;
quiver3(meshCentroid(:,1),meshCentroid(:,2),meshCentroid(:,3),scale*d*fMinTikh(1:3:end),scale*d*fMinTikh(2:3:end),scale*d*fMinTikh(3:3:end),0)
xlabel('x')
ylabel('y')
zlabel('z')
title({['Force Profile Computed via L2 Regularization; |f_{min}-f_{pinv}| = ' num2str(absErrorTikh)]; ['Tikhonov regularization: \lambda = ' num2str(reg_corner)]})
%view([90 0]) %use this if you want a view of the yz plane
% axis([domain_x domain_y [0 10]])

subplot(1,3,3)
quiver3(meshCentroid(:,1),meshCentroid(:,2),meshCentroid(:,3),d*fMinTikhArb(1:3:end),d*fMinTikhArb(2:3:end),d*fMinTikhArb(3:3:end),0)
xlabel('x')
ylabel('y')
zlabel('z')
title({['Force Profile Computed via L2 Regularization; |f_{min}-f_{pinv}| = ' num2str(absErrorTikhArb)]; ['Tikhonov regularization (arbitrary value): \lambda = ' num2str(regArb)]})
%view([90 0]) %use this if you want a view of the yz plane
% axis([domain_x domain_y [0 10]])

saveas(gcf, ['./plots/' runName 'inverseSolution_temp.png'])
%}
